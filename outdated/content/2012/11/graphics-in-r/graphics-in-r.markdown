UUID: 21443057-903b-44ae-b806-756ae32eeafc
Status: published
Date: 2012-11-11 18:28:16
Slug: graphics-in-r
Author: Ben Chuanlong Du
Title: Graphics in R
Category: Programming
Tags: par, R, plot, graphics, programming, CRAN, visualization
Modified: 2016-06-11 18:28:16

**
Things under legendu.net/outdated are outdated technologies 
that the author does not plan to update any more. 
Please look for better alternatives.
**


1. `par("din")` gets the dimension 
(i.e. width and height) of the graphics device.
If no graphics device has been open, 
it opens a new one.

2. To force a plot to have a fixed aspect ratio, 
you can use option `asp=aspRatio` in plotting function. 
For example, `plot(x, y, asp=1)` makes a scatter plot with aspect ratio 1. 
This is helpful when you do not want a plot to get stretched.

3. The function `title` adds titles and axes labels for an existing plot,
so if you forget to specify a title 
or axes labels when you use produce a plot, 
you can use `title` to add them into the plot
instead of producing a new plot 
(sometimes it is very time-consuming to produce a plot, 
e.g., when you analyze gene data.). 
`legend` adds legends for an existing plot. 
For example, see the code which produces the following image (need to add title).

![image](./res/title-legend.pdf)

4. Functions `pdf` and `postscript` starts the graphics device driver 
for producing `pdf` and `ps` graphics respectively, 
which are vectorgraph. 
Similarly, `jpeg`, `bmp`, `png` and `tiff` start graphics device driver 
for producing `jpeg`, `bmp`, `png` and `tiff` graphics, 
which are bitmaps.

5. There are several ways 
to divide a window device to sub window devices (to make plots on them). 
First, you can use `par`,
e.g. to divide a window device to $2\times3$ sub window devices, 
you can use `par(mfrow=c(2,3))` or  `par(mfcol=c(2,3))`. 
The difference between them is the first one display plots by rows 
while the second one display plots by columns. 
Second, 
you can use `layout{graphics}`, 
e.g. to divide a window device to two parts vertically 
and then further divide the bottom part into two horizontal parts, 
you can use `layout(matrix(c(1,2,1,3)))`. 
Same values in the matrix stand for the same area, 
and they also stand for the order they get used 
among all the sub window devices. 
Third,
you can use `split.screen`, 
e.g., 
to achieve what we did using `layout`, 
you can use the following command

```R
split.screen(c(2,1))
split.screen(c(1,2),2)
```

To make a plot on sub window device generated by `split.screen`, 
you must first active it. 
If you use functions in `lattice`, 
you will find that these basically ignore all these 3 functions. 
`lattice` has its own way to split window devices. 
To do this, 
you have first save plots made by functions in `lattice`, 
and then print these plot at appropriate locations using the generic `print`. 
For example, 
the following code make two plots using functions in `lattice`, 
and then using `print` to display them vertically.

```R
px1 = histogram(rnorm(1000))
px2 = bwplot(rnorm(1000))
# arrange the 2 plots vertically
print(px1, position=c(0, 0.6, 1, 1), more=TRUE)
print(px2, position=c(0, 0, 1, 0.4))
```

The first 2 values and the last 2 (3rd and last) values of the option `position` 
stand for x and y coordinates of the bottom-left and top-right corner, 
respectively,
of the panel to display the corresponding plot. 
Generally speaking, 
`par` is most easy one to use, 
but it can only divide a window device into rectangular sub window devices, 
and you must make plots in the right order for them to show up at the right places;  
`layout` is also easy to use. 
You can divide a window device into irregular shapes, 
but still you have to make plots in the right order 
to make them to show up at the right place;
`split.screen` is not as convenient as `par` and `layout`, 
but you can divide a window device into irregular sub window devices and
make plot on any sub window device (by calling `screen` first) whenever you want; 
perhaps it is most inconvenient to use `lattice` to achieve the same purpose. 
You must use functions in `lattice`, 
and you have to calculate positions for each sub window device 
and pass it to `print`. 
But `lattice` has some unique plotting functions 
and it uses more advanced technologies, 
you can reuse saved plots instead of replotting them every time. 
This is similar to how Mathematica handles graphics. 
My suggestion is that you never use `lattice` for this kind of job unless necessary.

6. Function `plot` is a generic function 
(actually many functions in R are generic functions), 
which be applied to many different types of objects in R.

7. Function `boxplot` can make plot of different data sets without
using function par().

8. Into order to recover to the default graph setting, we can save the
information of `par` first and reuse it whenever we want to go back
to the default settings.

9. `points` add points to a graph; `segments` add segments to a graph.
Though these job can be done by `plot`, these low level functions
are still useful.

10. Mathematica symbols can be used in title and labels of plots
using the `expression` function. 
For example,

```R
plot(1, xlab=expression(alpha+beta))
```

11. We can use math expression when plot a graph. To do this, we just
need specify the corresponding label as `expression(expr)`, where
"expr" is an appropriate expression in R. For example, if we want to
use Greek symbol $\alpha$, we can specify "xlab=expression(alpha)".
Whenver we forget how to write mathematica expressions, we can type
in command "demo(plotmath)" which will display corresponding
expression in R for all kinds of math expressions.

12. `sna::gplot.arrow` makes neat arrows.

13. `plot(..., type = "h")` gives us needle plot

14. `chull` computes convex hull of a given set.

15. `dev.copy2pdf` copies the graphics content on the current graphics
device to a pdf file.

6. You'd better use pdf with dev.off() to make plots, 
this is a universal way ...  
avoid problems when working on remote servers

[ggplot2 Book](http://ggplot2.org/book/)
